#include "lauxlib.h"
#include "lualib.h"
#include "time.h"
#include "lua_if.h"
#include "bsp.h"

static int lua_I2C_Start(lua_State *L);
static int lua_I2C_Stop(lua_State *L);
static int lua_I2C_SendBytes(lua_State *L);
static int lua_I2C_ReciveBytes(lua_State *L);

void lua_i2c_RegisterFun(void)
{
  //将指定的函数注册为Lua的全局函数变量，其中第一个字符串参数为Lua代码
  //在调用C函数时使用的全局函数名，第二个参数为实际C函数的指针。
  lua_register(g_Lua, "i2c_start", lua_I2C_Start);
  lua_register(g_Lua, "i2c_stop", lua_I2C_Stop);
  lua_register(g_Lua, "i2c_send", lua_I2C_SendBytes);
  lua_register(g_Lua, "i2c_recive", lua_I2C_ReciveBytes);
}

static int lua_I2C_Start(lua_State *L)
{
  i2c_Start();
  return 1;
}

static int lua_I2C_Stop(lua_State *L)
{
  i2c_Stop();
  return 1;
}

/*
  形式1: i2c_send(buf);
  形式2: i2c_send(32);	
*/
static int lua_I2C_SendBytes(lua_State *L)
{
  size_t i;
  size_t len;
  const char *data;
  uint8_t buf[1];
  int re;

  if (lua_type(L, 1) == LUA_TSTRING) /* 判断第1个参数 */
  {
    data = luaL_checklstring(L, 1, &len); /* 1是参数的位置， len是string的长度 */
  }

  if (lua_type(L, 1) == LUA_TNUMBER) /* 判断第1个参数 */
  {
    len = 1;
    buf[0] = luaL_checknumber(L, 1);

    data = (const char *)buf;
  }

  re = 1;
  for (i = 0; i < len; i++)
  {
    i2c_SendByte(data[i]);
    if (i2c_WaitAck() != 0)
    {
      i2c_Stop();
      re = 0;
      break;
    }
  }
  lua_pushnumber(L, re); /* 返回值 */
  return 1;
}

/*
Lua给C++传buffer时，使用string就行，再C++的，tolua++中使用下面代码读取buffer
        size_t ld;
        const char *data = luaL_checklstring(tolua_S, 2, &ld); // 2是参数的位置， ld是buffer的长度
C++给Lua传buffer时，在C++代码中使用下面代码传入buffer
            LuaStack *stack = LuaEngine::getInstance()->getLuaStack();
            stack->

*/
// lua_I2C_ReciveBytes(2);
static int lua_I2C_ReciveBytes(lua_State *L)
{
  size_t len;
  size_t i;

  len = luaL_checknumber(L, 1);
  if (len == 0 || len > LUA_READ_LEN_MAX)
  {
    lua_pushnumber(L, 0); /* 返回值 */
    return 0;
  }

  for (i = 0; i < len; i++)
  {
    s_lua_read_buf[i] = i2c_ReadByte(); /* 读1个字节 */

    /* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
    if (i != len - 1)
    {
      i2c_Ack(); /* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
    }
    else
    {
      i2c_NAck(); /* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
    }
  }

  //lua_pushnumber(L, 1);	/* 返回值 */
  //	strcpy(s_lua_read_buf, "s_lua_read_buf");
  lua_pushlstring(L, (char *)s_lua_read_buf, len);
  return 1;
}
